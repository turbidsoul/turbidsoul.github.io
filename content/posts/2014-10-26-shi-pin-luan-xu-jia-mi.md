Title: 视频乱序加密
Date: 2014-10-26
Modified: 2014-10-26
Category:  加密/解密
Tags: python, video, encrypt/decrypt
Slug: 2014-10-26-shi-pin-luan-xu-jia-mi.html
Authors: Turbidsoul Chan
Summary:最近公司网站总是被人攻击，这是出名节奏么？不过之前的防下载的技术已经被破解，所以现在需要做一种新的方式来防下载，不过不管用什么方法，防下载都是一种不够稳妥的方式，因为能播放就能下载，只要能找到对的方式，所以我们这次采用的加密的方法，对FLV文件内的TagBody内的数据进行加密，这样就可以在不影响视频播放的情况下对视频数据加密，就算防下载被破解，下载下的视频也是加过密的视频，播放的话都是雪花点之类的。

最近公司网站总是被人攻击，这是出名节奏么？不过之前的防下载的技术已经被破解，所以现在需要做一种新的方式来防下载，
不过不管用什么方法，防下载都是一种不够稳妥的方式，因为能播放就能下载，只要能找到对的方式，所以我们这次采用的加密的方法，
对FLV文件内的TagBody内的数据进行加密，这样就可以在不影响视频播放的情况下对视频数据加密，就算防下载被破解，下载下的视频也是加过密的视频，
播放的话都是雪花点之类的。

## 算法 ##

我们在这里不讨论视频的具体加密技术，因为涉及到公司的机密，只是简单的讨论这个算法。这个算法其实很简单，来自一片博士论文：[传送门](https://drive.google.com/file/d/0B1L569wdo3IkMFBISVlZZXVmRlk/view?usp=sharing)，也可以说`会者不难，难者不会`，我就属于后者不会的那个，
不过公司里有数学老师，我们头拿着这篇论文找到数学老师请教时候，果然很简单，当然我只搞懂了`等模乱序算法`，`变模乱序算法`还是没搞懂，我现在来简单的介绍一下等模乱序算法这个算法。

首先我们假设有一个序列：
> $M = (m(0), m(1), ......, m(n-1))$

和加密密钥
> $K = (k(0),k(1),......,k(n-1))$

通过$M$和$K$我们可以计算得到密文
> $C = (c(0),c(1),......,c(n-1))$。

$C$的计算公式就是
> $C = E_K(M)$

用于解密的密钥$R$:
> $R = (r(0),r(1),......r(n-1))$

解密公式:
> $M = D_R(C)$

这样我们的加密过程就是:
> $C = E_K(m(0),m(1),......,m(n-1)) = (m(k(0)),m(k(1)),......,m(k(n-1)))$

解密过程就是:
> $M = E_R(c(0),c(1),......,c(n-1)) = (c(r(0)),c(r(1)),......,c(r(n-1)))$

在这里我的$K$和$R$是可以互相推导的，即：
> $D_R(E_K(M)) = M$ 推导出 $r(k(j)) = j, k(r(j)) = j, j = 0, 1, ...,n-1$

通过上面的公式我们就能通过K推算出R，可能很多人看上面的这些看不懂，没有关系可以去看博士论文，论文上有更详细的说明，同时也有更进一步的扩展算法。
下面我举个例子来说明一下上面的算法：
原文:`m = [b,d,f,e,a]`

加密密钥:`k = [1, 4, 2, 0, 3]`

通过k对m乱序,获得密文:`c =[e, b, f, a, d]`

通过上面的$K$和$R$的推到公式,我们可以推导出:`r =  [3, 0, 2, 4, 1]`

我们最后用c和r重新解密出:`m = [b, d, f, e, a]`

这个例子是一个非常简单的例子，只是让人能更好的理解这个算法。下面我们在来看看使用`Python`做的简单实现。

## 算法的Python实现 ##

```python
data = ['a', 'c', 'e', 'd', 'g', 'f', 'h', 'b']
key = random.sample(range(0, len(data) + 1), len(data))

def encrypt(key, d):
    c = [v for _, v in sorted(list(zip(key, d)), key=lambda e: e[0])]
    r = [v for _, v in sorted(list(zip(key, range(0, len(key) + 1))), key=lambda e:e[0])]
    return (c, r)


def decrypt(r, d):
    m = [v for _, v in sorted(list(zip(r, d)), key=lambda e: e[0])]
    return m

print(data)
print(key)
c, r = encrypt(key, data)
print(c)
print(r)
m = decrypt(r, c)
print(m)
```

上面是我用python实现的乱序加密和机密代码，我这里用的是*generator*，其实可以直接带入上面的公式，这样更简单，也更容易理解。

## 结论 ##

其实视频的乱序加密并不是我所说的这么简单，其是本身非常复杂，我这里只是简单的介绍了一下乱序加密的思路，整个加密分两块：

* 服务端加密：服务端的加密方式有很多可以自由发挥，增加随机性。
* 客户端解密：客户端可以是web上，也可以是flash，或者是我们自己编写的播放器，不管那种我们都需要对客户端代码混淆，并实现流的解密。

其实不管如何，都不能做到100%的安全，我们这么做无非就是增加破解者的破解难度和成本，使其破解的成本高于视频价格。
